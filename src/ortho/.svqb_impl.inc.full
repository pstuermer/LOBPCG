/**
 * @file svqb_impl.inc
 * @brief Type-generic SVQB orthogonalization implementation
 *
 * SVQB: SVD-based Quasi-Block orthogonalization
 * Based on Algorithm 4/6 from Duersch 2018 / Stathopoulos
 *
 * Required macros before include:
 *   PREFIX  - type prefix (s, d, c, z)
 *   CTYPE   - computational type (f32, f64, c32, c64)
 *   RTYPE   - real type for norms/eigenvalues (f32, f64)
 *   LINOP   - LinearOperator type for this precision
 *
 * Algorithm (column-major):
 *   1. Gram: G = U^H*B*U (n×n) - herk/syrk if B=NULL, else gemm
 *   2. Diagonal scaling: D_ii = 1/sqrt(|G_ii|)
 *   3. Normalize: G_scaled = D*G*D
 *   4. Eigensolve: eig(G_scaled) → eigvals λ, eigvecs V
 *   5. Threshold: thresh = tau * max(|λ|)
 *   6. Transform: U_new = U * (D * V * D_final)
 *      where D_final_ii = 1/sqrt(max(|λ_i|, thresh))
 */

#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

/* Macro concatenation helpers */
#define CONCAT2(a, b) a##_##b
#define CONCAT(a, b) CONCAT2(a, b)
#define FN(name) CONCAT(PREFIX, name)

/* BLAS/LAPACK function macros - resolved at instantiation */
#define GRAM    FN(gram)
#define GEMM_NN FN(gemm_nn)
#define GEMM_HN FN(gemm_hn)
#define EIG     FN(eig)
#define NRM2    FN(nrm2)
#define COPY    FN(copy)
#define SCAL    FN(scal)

/* Complex magnitude helper */
#if defined(CTYPE_IS_COMPLEX)
  #define CABS(x) cabs(x)
  #define CREAL(x) creal(x)
#else
  #define CABS(x) fabs(x)
  #define CREAL(x) (x)
#endif

/* MAX macro */
#ifndef MAX
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#endif

/**
 * Helper: fill lower triangle from upper (Gram is symmetric/Hermitian)
 */
static void FN(fill_lower)(uint64_t n, CTYPE *A) {
    for (uint64_t j = 0; j < n; j++) {
        for (uint64_t i = j + 1; i < n; i++) {
            /* A[i,j] = conj(A[j,i]) */
            /* Column-major: A[i + j*n] = conj(A[j + i*n]) */
#if defined(CTYPE_IS_COMPLEX)
            A[i + j * n] = conj(A[j + i * n]);
#else
            A[i + j * n] = A[j + i * n];
#endif
        }
    }
}

/**
 * Helper: diagonal scaling of symmetric/Hermitian matrix
 * Computes B = D * A * D where D is diagonal with entries d[i]
 * A is n×n, d is length n, B is output n×n
 * In-place: B can alias A
 */
static void FN(diag_scale_sym)(uint64_t n, const RTYPE *d, const CTYPE *A, CTYPE *B) {
    for (uint64_t j = 0; j < n; j++) {
        for (uint64_t i = 0; i < n; i++) {
            B[i + j * n] = d[i] * A[i + j * n] * d[j];
        }
    }
}

/**
 * Helper: multiply matrix by diagonal on right
 * B = A * diag(d), where A is m×n, d is length n
 */
static void FN(scale_cols)(uint64_t m, uint64_t n, const CTYPE *A, const RTYPE *d, CTYPE *B) {
    for (uint64_t j = 0; j < n; j++) {
        CTYPE scale = (CTYPE)d[j];
        for (uint64_t i = 0; i < m; i++) {
            B[i + j * m] = A[i + j * m] * scale;
        }
    }
}

/**
 * Helper: multiply matrix by diagonal on left
 * B = diag(d) * A, where A is m×n, d is length m
 */
static void FN(scale_rows)(uint64_t m, uint64_t n, const RTYPE *d, const CTYPE *A, CTYPE *B) {
    for (uint64_t j = 0; j < n; j++) {
        for (uint64_t i = 0; i < m; i++) {
            B[i + j * m] = d[i] * A[i + j * m];
        }
    }
}

/**
 * SVQB orthogonalization
 *
 * @param m     Number of rows in U (problem size)
 * @param n     Number of columns in U (block size)
 * @param tau   Tolerance for small eigenvalues (relative to max)
 * @param drop  'n' = replace small with threshold, 'y' = randomize (stub)
 * @param U     Input/output matrix (m×n), orthogonalized in-place
 * @param wrk1  Workspace n×n (Gram → eigenvectors)
 * @param wrk2  Workspace m×n or n×n
 * @param wrk3  Workspace m×n or n×n
 * @param B     Optional B-operator for B-inner product (NULL = identity)
 * @return      Number of columns after dropping (always n for drop='n')
 */
uint64_t FN(svqb)(const uint64_t m, const uint64_t n, const RTYPE tau,
                  const char drop, CTYPE *restrict U,
                  CTYPE *restrict wrk1, CTYPE *restrict wrk2, CTYPE *restrict wrk3,
                  LINOP *B) {

    if (n == 0) return 0;

    /* Allocate eigenvalues array */
    RTYPE *eigvals = (RTYPE *)calloc(n, sizeof(RTYPE));
    RTYPE *diag_d = (RTYPE *)calloc(n, sizeof(RTYPE));
    if (!eigvals || !diag_d) {
        free(eigvals);
        free(diag_d);
        return 0;
    }

    /*
     * Step 1: Compute Gram matrix G = U^H * B * U
     * Store in wrk1 (n×n)
     */
    if (B == NULL) {
        /* Standard inner product: G = U^H * U via herk/syrk */
        /* Result in upper triangle of wrk1 */
        memset(wrk1, 0, n * n * sizeof(CTYPE));
        /* gram(nrows_of_U, ncols_of_U, alpha, U, beta, C) computes C = U^T*U */
        /* For column-major m×n matrix U, gram gives n×n result */
#if defined(CTYPE_IS_COMPLEX)
        CONCAT(PREFIX, herk)(n, m, (RTYPE)1.0, U, (RTYPE)0.0, wrk1);
#else
        CONCAT(PREFIX, syrk)(n, m, (RTYPE)1.0, U, (RTYPE)0.0, wrk1);
#endif
    } else {
        /* B-inner product: G = U^H * B * U */
        /* First compute BU in wrk2 column-by-column */
        for (uint64_t j = 0; j < n; j++) {
            B->matvec(B, &U[j * m], &wrk2[j * m]);
        }
        /* Then G = U^H * BU via gemm */
        memset(wrk1, 0, n * n * sizeof(CTYPE));
        GEMM_HN(n, n, m, (CTYPE)1.0, U, wrk2, (CTYPE)0.0, wrk1);
    }

    /* Fill lower triangle (eig needs full matrix) */
    FN(fill_lower)(n, wrk1);

    /*
     * Step 2: Extract diagonal scaling D_ii = 1/sqrt(|G_ii|)
     */
    for (uint64_t i = 0; i < n; i++) {
        RTYPE gii = CABS(wrk1[i + i * n]);
        if (gii > 0) {
            diag_d[i] = (RTYPE)1.0 / sqrt(gii);
        } else {
            diag_d[i] = (RTYPE)1.0;  /* Protect against zero columns */
        }
    }

    /*
     * Step 3: Compute scaled Gram matrix G_scaled = D * G * D
     * Store in wrk1 (overwrites Gram)
     */
    FN(diag_scale_sym)(n, diag_d, wrk1, wrk1);

    /*
     * Step 4: Eigensolve on scaled Gram matrix
     * eig overwrites wrk1 with eigenvectors, eigvals with eigenvalues
     * Eigenvalues returned in ascending order
     */
    int info = EIG(n, wrk1, eigvals);
    if (info != 0) {
        free(eigvals);
        free(diag_d);
        return n;  /* Return unchanged on failure */
    }

    /*
     * Step 5: Compute threshold
     */
    RTYPE max_eigval = (RTYPE)0.0;
    for (uint64_t i = 0; i < n; i++) {
        RTYPE absval = fabs(eigvals[i]);
        if (absval > max_eigval) max_eigval = absval;
    }
    RTYPE threshold = tau * max_eigval;

    /*
     * Step 6: Transform U based on drop mode
     */
    if (drop == 'n' || drop == 'N' || drop == 0) {
        /*
         * No dropping: replace small eigenvalues with threshold
         * U_new = U * D * V * D_final
         * where D_final_ii = 1/sqrt(max(|λ_i|, threshold))
         */

        /* Compute D_final */
        RTYPE *diag_final = (RTYPE *)calloc(n, sizeof(RTYPE));
        if (!diag_final) {
            free(eigvals);
            free(diag_d);
            return n;
        }

        for (uint64_t i = 0; i < n; i++) {
            RTYPE absval = fabs(eigvals[i]);
            diag_final[i] = (RTYPE)1.0 / sqrt(MAX(absval, threshold));
        }

        /* Compute T = D * V (n×n) in wrk2 */
        /* V is in wrk1, D is diag_d */
        FN(scale_rows)(n, n, diag_d, wrk1, wrk2);

        /* Compute T2 = T * D_final = D * V * D_final (n×n) in wrk3 */
        FN(scale_cols)(n, n, wrk2, diag_final, wrk3);

        /* Compute U_new = U * T2 */
        /* Store result in wrk2 (m×n), then copy to U */
        GEMM_NN(m, n, n, (CTYPE)1.0, U, wrk3, (CTYPE)0.0, wrk2);
        memcpy(U, wrk2, m * n * sizeof(CTYPE));

        free(diag_final);
    } else {
        /*
         * Dropping mode: stub for now
         * Would randomize weak columns and recursively call svqb
         */
        /* TODO: implement drop='y' path */
    }

    free(eigvals);
    free(diag_d);
    return n;
}

/* Clean up local macros */
#undef CONCAT2
#undef CONCAT
#undef FN
#undef GRAM
#undef GEMM_NN
#undef GEMM_HN
#undef EIG
#undef NRM2
#undef COPY
#undef SCAL
#undef CABS
#undef CREAL
#undef MAX
